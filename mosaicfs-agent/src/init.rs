use std::io::{self, BufRead, Write};
use std::path::{Path, PathBuf};

use reqwest::Client;
use tracing::info;

const DEFAULT_CONFIG_PATH: &str = "/etc/mosaicfs/agent.toml";

/// Run the interactive agent init flow.
pub async fn run_init() -> anyhow::Result<()> {
    println!("MosaicFS Agent Setup");
    println!("====================\n");

    // 1. Control plane URL
    let control_plane_url = prompt("Control plane URL", "https://localhost:8443")?;

    // 2. Credentials
    let access_key_id = prompt("Access Key ID", "")?;
    if access_key_id.is_empty() {
        anyhow::bail!("Access Key ID is required");
    }

    let secret_key = prompt_secret("Secret Key")?;
    if secret_key.is_empty() {
        anyhow::bail!("Secret Key is required");
    }

    // 3. Watch paths
    let watch_paths_str = prompt("Watch paths (comma-separated)", "/home")?;
    let watch_paths: Vec<PathBuf> = watch_paths_str
        .split(',')
        .map(|s| PathBuf::from(s.trim()))
        .collect();

    for p in &watch_paths {
        if !p.is_absolute() {
            anyhow::bail!("Watch path must be absolute: {}", p.display());
        }
    }

    // 4. Register node with control plane
    println!("\nRegistering node with control plane...");
    let node_id = register_with_server(&control_plane_url, &access_key_id, &secret_key).await?;
    println!("Registered as node: {}", node_id);

    // 5. Write agent.toml
    let config_path = prompt("Config file path", DEFAULT_CONFIG_PATH)?;
    let config_path = PathBuf::from(&config_path);

    if let Some(parent) = config_path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    let watch_paths_toml: Vec<String> = watch_paths
        .iter()
        .map(|p| format!("\"{}\"", p.display()))
        .collect();

    let config_content = format!(
        r#"# MosaicFS Agent Configuration
# Generated by mosaicfs-agent init

control_plane_url = "{}"
node_id = "{}"
watch_paths = [{}]
excluded_paths = []
access_key_id = "{}"
secret_key = "{}"
"#,
        control_plane_url,
        node_id,
        watch_paths_toml.join(", "),
        access_key_id,
        secret_key,
    );

    std::fs::write(&config_path, &config_content)?;
    println!("Config written to: {}", config_path.display());

    // 6. Set inotify watches on Linux
    #[cfg(target_os = "linux")]
    set_inotify_watches();

    // 7. Install service
    install_service(&config_path)?;

    println!("\nSetup complete! The agent service has been configured.");
    println!("Start it with: systemctl start mosaicfs-agent (Linux) or launchctl load ~/Library/LaunchAgents/com.mosaicfs.agent.plist (macOS)");

    Ok(())
}

fn prompt(label: &str, default: &str) -> anyhow::Result<String> {
    if default.is_empty() {
        print!("{}: ", label);
    } else {
        print!("{} [{}]: ", label, default);
    }
    io::stdout().flush()?;

    let mut line = String::new();
    io::stdin().lock().read_line(&mut line)?;
    let line = line.trim().to_string();
    if line.is_empty() {
        Ok(default.to_string())
    } else {
        Ok(line)
    }
}

fn prompt_secret(label: &str) -> anyhow::Result<String> {
    print!("{}: ", label);
    io::stdout().flush()?;

    // Try to disable echo; fall back to normal read
    let mut line = String::new();
    io::stdin().lock().read_line(&mut line)?;
    let result = line.trim().to_string();
    println!(); // newline after hidden input
    Ok(result)
}

async fn register_with_server(
    url: &str,
    access_key_id: &str,
    secret_key: &str,
) -> anyhow::Result<String> {
    // First, login to get a JWT token
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .build()?;

    let login_resp = client
        .post(format!("{}/api/auth/login", url))
        .json(&serde_json::json!({
            "access_key_id": access_key_id,
            "secret_key": secret_key,
        }))
        .send()
        .await?;

    if !login_resp.status().is_success() {
        let body: serde_json::Value = login_resp.json().await?;
        let msg = body
            .get("error")
            .and_then(|e| e.get("message"))
            .and_then(|m| m.as_str())
            .unwrap_or("Login failed");
        anyhow::bail!("Login failed: {}", msg);
    }

    let login_body: serde_json::Value = login_resp.json().await?;
    let token = login_body
        .get("token")
        .and_then(|v| v.as_str())
        .ok_or_else(|| anyhow::anyhow!("No token in login response"))?;

    // Register node
    let hostname = hostname::get()
        .map(|h| h.to_string_lossy().to_string())
        .unwrap_or_else(|_| "unknown".to_string());

    let register_resp = client
        .post(format!("{}/api/nodes", url))
        .bearer_auth(token)
        .json(&serde_json::json!({
            "friendly_name": hostname,
            "platform": std::env::consts::OS,
        }))
        .send()
        .await?;

    if !register_resp.status().is_success() {
        let body: serde_json::Value = register_resp.json().await?;
        let msg = body
            .get("error")
            .and_then(|e| e.get("message"))
            .and_then(|m| m.as_str())
            .unwrap_or("Registration failed");
        anyhow::bail!("Node registration failed: {}", msg);
    }

    let reg_body: serde_json::Value = register_resp.json().await?;
    let node_id = reg_body
        .get("node_id")
        .and_then(|v| v.as_str())
        .ok_or_else(|| anyhow::anyhow!("No node_id in registration response"))?;

    Ok(node_id.to_string())
}

#[cfg(target_os = "linux")]
fn set_inotify_watches() {
    let sysctl_path = "/etc/sysctl.d/99-mosaicfs.conf";
    let content = "fs.inotify.max_user_watches = 524288\n";

    match std::fs::write(sysctl_path, content) {
        Ok(_) => {
            info!("Set fs.inotify.max_user_watches = 524288");
            let _ = std::process::Command::new("sysctl")
                .arg("-p")
                .arg(sysctl_path)
                .output();
        }
        Err(e) => {
            eprintln!("Warning: Could not set inotify watches (run as root): {}", e);
        }
    }
}

fn install_service(config_path: &Path) -> anyhow::Result<()> {
    let config_str = config_path.display().to_string();

    #[cfg(target_os = "linux")]
    {
        let unit = format!(
            r#"[Unit]
Description=MosaicFS Agent
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/mosaicfs-agent {}
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
"#,
            config_str,
        );

        let unit_path = "/etc/systemd/system/mosaicfs-agent.service";
        match std::fs::write(unit_path, &unit) {
            Ok(_) => {
                println!("Systemd unit written to: {}", unit_path);
                let _ = std::process::Command::new("systemctl")
                    .args(["daemon-reload"])
                    .output();
            }
            Err(e) => {
                eprintln!("Warning: Could not write systemd unit (run as root): {}", e);
            }
        }
    }

    #[cfg(target_os = "macos")]
    {
        let home = std::env::var("HOME").unwrap_or_else(|_| "/tmp".to_string());
        let plist_dir = format!("{}/Library/LaunchAgents", home);
        std::fs::create_dir_all(&plist_dir)?;
        let plist_path = format!("{}/com.mosaicfs.agent.plist", plist_dir);

        let plist = format!(
            r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.mosaicfs.agent</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/mosaicfs-agent</string>
        <string>{}</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>"#,
            config_str,
        );

        std::fs::write(&plist_path, &plist)?;
        println!("LaunchAgent plist written to: {}", plist_path);
    }

    Ok(())
}
